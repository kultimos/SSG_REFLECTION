# cglib动态代理
  JDK动态代理有一个前提,需要代理的类必须实现接口,如果没有实现接口,只能通过cglib来实现,其实就是对于JDK动态代理的一个补充
  
# cglib动态代理的流程
  我们需要引入cglib相关依赖
  跟JDK的动态代理类似,cglib中也需要我们去继承一个方法拦截器 CglibInterceptor,重写其intercept()方法,该方法有四个参数
  分别是我们创建的代理对象实例,方法对象的实例,参数列表和cglib框架提供的一个MethodProxy实例,这里有一点需要注意,我们使用cglib其实就是弥补jdk动态代理
无法代理类的遗憾,所以这里我们创建的代理对象其实是我们要代理的类的子类,也是通过继承的方式去获取目标对象的方法;方法对象的实例可以帮助我们进行判断,具体对哪些方法
进行增强,而最终调用方法是依赖MethodProxy.superInvoke(o)的方式来实现方法的调用;这部分承担的工作其实跟JDK动态代理中的handler一样,就是拦截指定方法进行加强;
  至于使用,我们需要创建一个Enhancer对象,设置其父类字节码即指明要代理的类,然后设置一个回调,即我们重写的interceptor方法拦截器,最后调用Enhancer对象的create()方法
即可完成代理对象的方法调用;
  那么上面是准备工作:
  具体呢就是创建一个代理类,设置其父类为要代理的类,设置我们的interceptor拦截器,这样在执行代理对象的方法调用时,代码就会进入我们设置的拦截器,根据拦截器里的逻辑,
对原有类的方法进行增强,而最终调用的方式是通过代理对象MethodProxy.superInvoker(代理对象, args[])的方式实现调用要代理类的方法;

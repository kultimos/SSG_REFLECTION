# 静态代理的问题

# JDK动态代理
  在不改变原有功能代码的前提下,能够动态的实现方法的增强;
  JDK动态代理是基于拦截器和反射实现的;
  
# JDK动态代理流程
  JDK动态代理是基于拦截器和反射实现的;JDK动态代理只能对接口进行代理或者说jdk动态代理的类必须要实现接口,因为Proxy.newProxyInstance()方法的第二个参数必须是一个接口数组
  两个重要的类是Proxy和InvocationHandler;
  - Proxy 通过Proxy.newProxyInstance()方法,应用反射机制创建出一个代理对象,该方法有三个参数,分别是类加载器,目标类实现的一组接口和一个拦截器对象(我们重写的InvocationHandler);
          之后就可以用该代理对象进行方法的调用;
  - InvocationHandler 是一个拦截器,我们通过写一个类继承该拦截器,并重写其方法,在这个过程中我们可能根据自己的需求对不同的方法进行个性化的增强,并且再这里也是通过反射来实现方法的调用,
                      拦截器中也有三个参数,分别是proxy对象、method名和参数列表,这里的方法调用也是通过method.invoke(目标类,args)反射的方式实现的;

  这样当我们执行Proxy对象的方法调用时,拦截器就会对其进行拦截,根据我们的逻辑对不同方法进行增强;
  具体的代码实现可见: handler包、po包、service包、transcation包和test包下的测试类;
  